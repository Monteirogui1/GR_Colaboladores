from django.utils import timezone
from django.db import models
from django.conf import settings
import secrets
import string
import hashlib
from datetime import datetime
from django.contrib.postgres.fields import JSONField

class MachineGroup(models.Model):
    name = models.CharField("Nome do Grupo", max_length=100)
    description = models.TextField("Descrição", blank=True)

    def __str__(self):
        return self.name

    class Meta:
        verbose_name = "Grupo de Máquinas"
        verbose_name_plural = "Grupos de Máquinas"


class Machine(models.Model):
    loggedUser = models.CharField("loggedUser", max_length=200, null=True, blank=True)
    hostname        = models.CharField("Hostname", max_length=100, unique=True)
    ip_address      = models.GenericIPAddressField("IP")
    mac_address     = models.CharField("MAC Address", max_length=17, null=True, blank=True)
    os_version      = models.CharField("Versão do SO", max_length=100, null=True, blank=True)
    tpm = models.JSONField("TpmInfo", null=True, blank=True)

    # RAM slots
    total_memory_slots = models.IntegerField("Slots Totais", null=True, blank=True)
    populated_memory_slots = models.IntegerField("Slots Ocupados", null=True, blank=True)
    memory_modules = models.JSONField("Módulos de Memória", null=True, blank=True)

    manufacturer    = models.CharField("Fabricante", max_length=100, null=True, blank=True)
    model           = models.CharField("Modelo", max_length=100, null=True, blank=True)
    serial_number   = models.CharField("Serial BIOS", max_length=100, null=True, blank=True)
    bios_version    = models.CharField("Versão BIOS", max_length=100, null=True, blank=True)
    bios_release    = models.CharField("Data BIOS", max_length=50, null=True, blank=True)
    os_caption      = models.CharField("SO Caption", max_length=200, null=True, blank=True)
    os_architecture = models.CharField("Arquitetura SO", max_length=50, null=True, blank=True)
    os_build        = models.CharField("Build SO", max_length=20, null=True, blank=True)
    install_date    = models.CharField("Instalação SO", max_length=30, null=True, blank=True)
    last_boot       = models.CharField("Último Boot", max_length=30, null=True, blank=True)
    uptime_days     = models.FloatField("Uptime (dias)", null=True, blank=True)

    cpu             = models.CharField("CPU", max_length=200, null=True, blank=True)
    ram_gb          = models.FloatField("RAM (GB)", null=True, blank=True)
    disk_space_gb   = models.FloatField("Disco Total (GB)", null=True, blank=True)
    disk_free_gb    = models.FloatField("Disco Livre (GB)", null=True, blank=True)

    network_info    = models.JSONField("Adaptadores Rede", null=True, blank=True)
    gpu_name        = models.CharField("Placa de Vídeo", max_length=200, null=True, blank=True)
    gpu_driver      = models.CharField("Driver Vídeo", max_length=100, null=True, blank=True)
    antivirus_name  = models.CharField("Antivírus", max_length=200, null=True, blank=True)
    av_state        = models.CharField("Estado AV", max_length=50, null=True, blank=True)

    last_seen = models.DateTimeField("Última Conexão", auto_now=True)
    is_online = models.BooleanField("Online", default=False)
    group     = models.ForeignKey(MachineGroup, on_delete=models.SET_NULL, null=True, blank=True)

    def __str__(self):
        return self.hostname

    class Meta:
        verbose_name = "Máquina"
        verbose_name_plural = "Máquinas"


class BlockedSite(models.Model):
    url = models.CharField("URL Bloqueada", max_length=255)
    machine = models.ForeignKey(Machine, on_delete=models.CASCADE, null=True, blank=True, verbose_name="Máquina")
    group = models.ForeignKey(MachineGroup, on_delete=models.CASCADE, null=True, blank=True, verbose_name="Grupo")

    class Meta:
        unique_together = (('url', 'machine'), ('url', 'group'))
        verbose_name = "Site Bloqueado"
        verbose_name_plural = "Sites Bloqueados"

    def __str__(self):
        target = self.machine or self.group
        return f"{self.url} → {target}"


class Notification(models.Model):
    """
    Notificação para ser exibida no agente da máquina cliente

    Campos:
        - machine: Máquina que receberá a notificação
        - title: Título da notificação
        - message: Mensagem/conteúdo da notificação
        - type: Tipo de notificação (info, success, warning, error, alert, critical)
        - priority: Prioridade (low, normal, high, critical)
        - status: Status da notificação (pending, read, expired)
        - is_read: Flag booleana se foi lida
        - created_at: Data de criação
        - updated_at: Data de última atualização
        - read_at: Data em que foi lida
        - expires_at: Data de expiração (opcional)
    """

    # Choices para tipo de notificação
    TYPE_CHOICES = [
        ('info', 'Informação'),
        ('success', 'Sucesso'),
        ('warning', 'Aviso'),
        ('error', 'Erro'),
        ('alert', 'Alerta'),
        ('critical', 'Crítico'),
    ]

    # Choices para prioridade
    PRIORITY_CHOICES = [
        ('low', 'Baixa'),
        ('normal', 'Normal'),
        ('high', 'Alta'),
        ('critical', 'Crítica'),
    ]

    # Choices para status
    STATUS_CHOICES = [
        ('pending', 'Pendente'),
        ('read', 'Lida'),
        ('expired', 'Expirada'),
    ]

    # Relacionamento com a máquina
    machine = models.ForeignKey(
        'Machine',
        on_delete=models.CASCADE,
        related_name='notifications',
        verbose_name='Máquina',
        help_text='Máquina que receberá a notificação'
    )

    # Conteúdo da notificação
    title = models.CharField(
        max_length=200,
        verbose_name='Título',
        help_text='Título da notificação (máximo 200 caracteres)'
    )

    message = models.TextField(
        verbose_name='Mensagem',
        help_text='Conteúdo detalhado da notificação'
    )

    # Tipo e prioridade
    type = models.CharField(
        max_length=20,
        choices=TYPE_CHOICES,
        default='info',
        verbose_name='Tipo',
        help_text='Tipo de notificação (define ícone e cor)'
    )

    priority = models.CharField(
        max_length=20,
        choices=PRIORITY_CHOICES,
        default='normal',
        verbose_name='Prioridade',
        help_text='Prioridade da notificação'
    )

    # Status e controle
    status = models.CharField(
        max_length=20,
        choices=STATUS_CHOICES,
        default='pending',
        verbose_name='Status',
        help_text='Status atual da notificação'
    )

    is_read = models.BooleanField(
        default=False,
        verbose_name='Lida',
        help_text='Indica se a notificação já foi lida pelo usuário'
    )

    # Timestamps
    created_at = models.DateTimeField(
        auto_now_add=True,
        verbose_name='Criada em',
        help_text='Data e hora de criação da notificação'
    )

    updated_at = models.DateTimeField(
        auto_now=True,
        verbose_name='Atualizada em',
        null=True,
        blank=True,
        help_text='Data e hora da última atualização'
    )

    read_at = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name='Lida em',
        help_text='Data e hora em que foi lida pelo usuário'
    )

    expires_at = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name='Expira em',
        help_text='Data e hora de expiração (opcional)'
    )

    class Meta:
        ordering = ['-created_at']
        verbose_name = 'Notificação'
        verbose_name_plural = 'Notificações'

    def __str__(self):
        return f'{self.machine.hostname} - {self.title}'

    def mark_as_read(self):
        """
        Marca a notificação como lida

        Atualiza:
            - is_read = True
            - status = 'read'
            - read_at = agora
        """
        self.is_read = True
        self.status = 'read'
        self.read_at = timezone.now()
        self.save(update_fields=['is_read', 'status', 'read_at'])

    def is_expired(self):
        """
        Verifica se a notificação está expirada

        Returns:
            bool: True se expirada, False caso contrário
        """
        if self.expires_at:
            return timezone.now() > self.expires_at
        return False

    def mark_as_expired(self):
        """Marca a notificação como expirada"""
        self.status = 'expired'
        self.save(update_fields=['status'])

    @property
    def age_in_hours(self):
        """
        Retorna a idade da notificação em horas

        Returns:
            float: Número de horas desde a criação
        """
        delta = timezone.now() - self.created_at
        return delta.total_seconds() / 3600

    @property
    def is_urgent(self):
        """
        Verifica se a notificação é urgente

        Returns:
            bool: True se prioridade é high ou critical
        """
        return self.priority in ['high', 'critical']

    def save(self, *args, **kwargs):
        """
        Override do save para lógica adicional

        - Se expirada, muda status automaticamente
        - Se marcada como lida, atualiza read_at
        """
        # Verificar expiração
        if self.expires_at and timezone.now() > self.expires_at:
            self.status = 'expired'

        # Se foi marcada como lida mas não tem read_at, adicionar
        if self.is_read and not self.read_at:
            self.read_at = timezone.now()
            self.status = 'read'

        super().save(*args, **kwargs)


class AgentToken(models.Model):
    """Token de instalação do agente"""

    token = models.CharField(max_length=8, unique=True, verbose_name="Token")
    token_hash = models.CharField(max_length=64, unique=True, verbose_name="Hash do Token")
    machine_name = models.CharField(
        max_length=255,
        blank=True,
        null=True,
        verbose_name="Nome da Máquina"
    )
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='created_tokens',
        verbose_name="Criado por"
    )
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="Criado em")
    used_at = models.DateTimeField(
        blank=True,
        null=True,
        verbose_name="Usado em"
    )
    is_active = models.BooleanField(default=True, verbose_name="Ativo")
    expires_at = models.DateTimeField(verbose_name="Expira em")

    class Meta:
        ordering = ['-created_at']
        verbose_name = "Token do Agente"
        verbose_name_plural = "Tokens do Agente"
        db_table = 'inventory_agent_token'

    def __str__(self):
        return f"Token {self.token} - {self.created_at.strftime('%Y-%m-%d')}"

    @staticmethod
    def generate_token():
        """Gera token de 8 caracteres com números, letras e especiais"""
        uppercase = string.ascii_uppercase
        lowercase = string.ascii_lowercase
        digits = string.digits
        special = "!@#$%&*"

        # Garante pelo menos 1 de cada tipo
        token_chars = [
            secrets.choice(uppercase),
            secrets.choice(lowercase),
            secrets.choice(digits),
            secrets.choice(special)
        ]

        # Completa com caracteres aleatórios
        all_chars = uppercase + lowercase + digits + special
        token_chars.extend(secrets.choice(all_chars) for _ in range(4))

        # Embaralha
        token = list(token_chars)
        secrets.SystemRandom().shuffle(token)

        return ''.join(token)

    @staticmethod
    def hash_token(token):
        """Cria hash do token"""
        return hashlib.sha256(token.encode()).hexdigest()

    def is_expired(self):
        """Verifica se o token expirou"""
        now = timezone.now()
        # Garante que ambos são timezone-aware para comparação
        if timezone.is_naive(self.expires_at):
            # Se expires_at é naive, torna timezone-aware
            expires_at = timezone.make_aware(self.expires_at)
        else:
            expires_at = self.expires_at

        return now > expires_at

    def mark_as_used(self, machine_name):
        """Marca token como usado"""
        self.used_at = timezone.now()
        self.machine_name = machine_name
        self.save()

    def get_status_display(self):
        """Retorna o status do token para exibição"""
        if not self.is_active:
            return {'text': 'Inativo', 'class': 'secondary'}
        elif self.is_expired():
            return {'text': 'Expirado', 'class': 'warning'}
        elif self.used_at:
            return {'text': 'Usado', 'class': 'info'}
        else:
            return {'text': 'Disponível', 'class': 'success'}


class AgentVersion(models.Model):
    """Versões do agente disponíveis"""

    version = models.CharField(max_length=20, unique=True, verbose_name="Versão")
    file_path = models.FileField(
        upload_to='agent_versions/',
        verbose_name="Arquivo"
    )
    release_notes = models.TextField(verbose_name="Notas de Lançamento")
    is_active = models.BooleanField(default=True, verbose_name="Ativo")
    is_mandatory = models.BooleanField(
        default=False,
        verbose_name="Atualização Obrigatória"
    )
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="Criado em")
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        verbose_name="Criado por"
    )

    class Meta:
        ordering = ['-created_at']
        verbose_name = "Versão do Agente"
        verbose_name_plural = "Versões do Agente"
        

    def __str__(self):
        return f"Versão {self.version}"

    def get_status_display(self):
        """Retorna o status da versão para exibição"""
        if self.is_active:
            if self.is_mandatory:
                return {'text': 'Ativa (Obrigatória)', 'class': 'danger'}
            return {'text': 'Ativa', 'class': 'success'}
        return {'text': 'Inativa', 'class': 'secondary'}